
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

* [标志寄存器](#标志寄存器)
* [相关指令](#相关指令)
* [例子1](#例子1)
* [例子2](#例子2)

<!-- /code_chunk_output -->



# 标志寄存器

标志寄存器(简称`flag`)（其中存储的信息通常被称为程序状态字`PSW`）的作用：
1. 用来存储相关指令的某些执行结果
2. 用来为cpu执行相关指令提供行为依据
3. 用来控制CPU的相关工作方式

`flag`寄存器按位起作用，每一位都有专门的含义。

![](./image/标志.png)

|标志|功能|
|:---:|:---|
|`zf`零标志位|记录相关指令执行后，其结果是否为0<br>相关指令结果为0，`zf`=1<br>相关指令结果为1，`zf`=0<br>`add`、`sub`、`mul`、`div`、`inc`、`or`、`and`|
|`pf`|奇偶标志位<br>记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数<br>如果1的个数为偶数，pf=1|
|`sf`|符号标志位<br>记录相关指令执行后，其结果是否为负<br>相关指令为负，sf=1<br>将数据当作有符号数来计算的时候，可以通过它来得到结果的正负<br>将数据当作无符号数来计算的时候，虽然会影响sf的值但此时，sf的值没意义|
|`cf`|进位标志<br>记录了运算结果的最高有效位向更高有效位的进位值，或从更高位的借位值|
|`of`|溢出标志<br>针对有符号数而言<br>cf是对无符号数运算有意义的标志位<br>of是有符号数运算有意义的标志位<br>sf记录结果的符号<br>`mov al,98`<br>`add al,99`<br>cf=0,of=1|

# 相关指令

|指令|功能|例子|
|:---:|:---|:---|
|`adc`|带进位加法指令<br>利用了`cf`位上记录的进位值<br>指令格式：`abc obj1,obj2`<br>功能：`obj1=obj1+obj2+cf`<br>此处cf的值是adc前面的指令决定的<br>通过adc指令，我们可以对任意大的数据进行加法计算<br>[例子1](#例子1)<br>inc和loop不影响cf位|`add al,bl`<br>`adc ah,bh`<br>等同于`add ax,bx`|
|`sbb`|带借位减法指令<br>利用了`cf`位上记录的借位值<br>指令格式：`sbb obj1,obj2`<br>功能：`obj1=(obj1-obj2-cf)`<br>利用`obb`对任意大的数据进行减法运算|[例子2](#例子2)|
|`cmp`|比较指令<br>相当减法指令，只是不保存结果<br>执行后，将对标志寄存器产生影响<br>其他指令通过识别这些被影响的标志寄存器得知比较结果<br>指令格式：`cmp obj1,obj2`<br>功能：计算`obj1-obj2`,并不保存结果，仅影响`flag`相关位<br>具体情况见下图|`cmp ax,ax`<br>`zf=pf=1`<br>`sf=cf=of=0`|
|``|||
![](./image/cmp.png)

# 例子1

计算1ef0001000h+2010001ef0h，结果放在ax，bx，cx中

```asm
mov ax,001eh
mov bx,0f000h
mov cx,1000h
adc cx,1ef0h
adc bx,1000h
abc ax,0020h
```

# 例子2

计算003e1000h-00202000h:

```asm
mov bx,1000h
mov ax,003e
sub bx,2000h
sbb ax,0020
```